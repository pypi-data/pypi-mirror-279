"""
@generated by mypy-protobuf.  Do not edit manually!
isort:skip_file
*
Copyright 2020 Alibaba Group Holding Limited.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
"""

import builtins
import collections.abc
import common_pb2
import google.protobuf.descriptor
import google.protobuf.internal.containers
import google.protobuf.internal.enum_type_wrapper
import google.protobuf.message
import sys
import type_pb2
import typing

if sys.version_info >= (3, 10):
    import typing as typing_extensions
else:
    import typing_extensions

DESCRIPTOR: google.protobuf.descriptor.FileDescriptor

class _Logical:
    ValueType = typing.NewType("ValueType", builtins.int)
    V: typing_extensions.TypeAlias = ValueType

class _LogicalEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_Logical.ValueType], builtins.type):
    DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
    EQ: _Logical.ValueType  # 0
    """A binary equality operator"""
    NE: _Logical.ValueType  # 1
    """A binary inequality operator"""
    LT: _Logical.ValueType  # 2
    """A binary less-than operator"""
    LE: _Logical.ValueType  # 3
    """A binary less-than-equal operator"""
    GT: _Logical.ValueType  # 4
    """A binary greater-than operator"""
    GE: _Logical.ValueType  # 5
    """A binary greater-than-equal operator"""
    WITHIN: _Logical.ValueType  # 6
    """A binary containment check operator, e.g 1 WITHIN [1, 2, 3, 4]"""
    WITHOUT: _Logical.ValueType  # 7
    """A binary not-containment check operator, e.g 5 WITHOUT [1, 2, 3, 4]"""
    STARTSWITH: _Logical.ValueType  # 8
    """A binary operator to verify whether a string is a prefix of another string"""
    ENDSWITH: _Logical.ValueType  # 9
    """A binary operator to verify whether a string is a suffix of another string"""
    AND: _Logical.ValueType  # 10
    """A binary logical and operator."""
    OR: _Logical.ValueType  # 11
    """A binary logical or operator."""
    NOT: _Logical.ValueType  # 12
    """A unary logical not operator."""
    ISNULL: _Logical.ValueType  # 13
    """A unary logical isnull operator"""
    REGEX: _Logical.ValueType  # 14
    """A binary operator to verify whether a string matches a regular expression"""

class Logical(_Logical, metaclass=_LogicalEnumTypeWrapper): ...

EQ: Logical.ValueType  # 0
"""A binary equality operator"""
NE: Logical.ValueType  # 1
"""A binary inequality operator"""
LT: Logical.ValueType  # 2
"""A binary less-than operator"""
LE: Logical.ValueType  # 3
"""A binary less-than-equal operator"""
GT: Logical.ValueType  # 4
"""A binary greater-than operator"""
GE: Logical.ValueType  # 5
"""A binary greater-than-equal operator"""
WITHIN: Logical.ValueType  # 6
"""A binary containment check operator, e.g 1 WITHIN [1, 2, 3, 4]"""
WITHOUT: Logical.ValueType  # 7
"""A binary not-containment check operator, e.g 5 WITHOUT [1, 2, 3, 4]"""
STARTSWITH: Logical.ValueType  # 8
"""A binary operator to verify whether a string is a prefix of another string"""
ENDSWITH: Logical.ValueType  # 9
"""A binary operator to verify whether a string is a suffix of another string"""
AND: Logical.ValueType  # 10
"""A binary logical and operator."""
OR: Logical.ValueType  # 11
"""A binary logical or operator."""
NOT: Logical.ValueType  # 12
"""A unary logical not operator."""
ISNULL: Logical.ValueType  # 13
"""A unary logical isnull operator"""
REGEX: Logical.ValueType  # 14
"""A binary operator to verify whether a string matches a regular expression"""
global___Logical = Logical

class _Arithmetic:
    ValueType = typing.NewType("ValueType", builtins.int)
    V: typing_extensions.TypeAlias = ValueType

class _ArithmeticEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_Arithmetic.ValueType], builtins.type):
    DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
    ADD: _Arithmetic.ValueType  # 0
    """A binary addition operator"""
    SUB: _Arithmetic.ValueType  # 1
    """A binary subtraction operator"""
    MUL: _Arithmetic.ValueType  # 2
    """A binary multiplication operator"""
    DIV: _Arithmetic.ValueType  # 3
    """A binary division operator"""
    MOD: _Arithmetic.ValueType  # 4
    """A binary modulo operator"""
    EXP: _Arithmetic.ValueType  # 5
    """A binary exponentiation operator"""
    BITAND: _Arithmetic.ValueType  # 6
    """A binary bitwise and operator"""
    BITOR: _Arithmetic.ValueType  # 7
    """A binary bitwise or operator"""
    BITXOR: _Arithmetic.ValueType  # 8
    """A binary bitwise or operator"""
    BITLSHIFT: _Arithmetic.ValueType  # 9
    """A binary bitwise left-shift operator"""
    BITRSHIFT: _Arithmetic.ValueType  # 10
    """A binary bitwise right-shift operator"""

class Arithmetic(_Arithmetic, metaclass=_ArithmeticEnumTypeWrapper): ...

ADD: Arithmetic.ValueType  # 0
"""A binary addition operator"""
SUB: Arithmetic.ValueType  # 1
"""A binary subtraction operator"""
MUL: Arithmetic.ValueType  # 2
"""A binary multiplication operator"""
DIV: Arithmetic.ValueType  # 3
"""A binary division operator"""
MOD: Arithmetic.ValueType  # 4
"""A binary modulo operator"""
EXP: Arithmetic.ValueType  # 5
"""A binary exponentiation operator"""
BITAND: Arithmetic.ValueType  # 6
"""A binary bitwise and operator"""
BITOR: Arithmetic.ValueType  # 7
"""A binary bitwise or operator"""
BITXOR: Arithmetic.ValueType  # 8
"""A binary bitwise or operator"""
BITLSHIFT: Arithmetic.ValueType  # 9
"""A binary bitwise left-shift operator"""
BITRSHIFT: Arithmetic.ValueType  # 10
"""A binary bitwise right-shift operator"""
global___Arithmetic = Arithmetic

@typing.final
class IdKey(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    def __init__(
        self,
    ) -> None: ...

global___IdKey = IdKey

@typing.final
class LabelKey(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    def __init__(
        self,
    ) -> None: ...

global___LabelKey = LabelKey

@typing.final
class LengthKey(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    def __init__(
        self,
    ) -> None: ...

global___LengthKey = LengthKey

@typing.final
class AllKey(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    def __init__(
        self,
    ) -> None: ...

global___AllKey = AllKey

@typing.final
class NameOrIdKey(google.protobuf.message.Message):
    """Use `NameOrId` as key item, which is the same as `Option<NameOrId>`"""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    KEY_FIELD_NUMBER: builtins.int
    @property
    def key(self) -> common_pb2.NameOrId: ...
    def __init__(
        self,
        *,
        key: common_pb2.NameOrId | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["key", b"key"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["key", b"key"]) -> None: ...

global___NameOrIdKey = NameOrIdKey

@typing.final
class Property(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    ID_FIELD_NUMBER: builtins.int
    LABEL_FIELD_NUMBER: builtins.int
    LEN_FIELD_NUMBER: builtins.int
    ALL_FIELD_NUMBER: builtins.int
    KEY_FIELD_NUMBER: builtins.int
    @property
    def id(self) -> global___IdKey:
        """Get id from the entity"""

    @property
    def label(self) -> global___LabelKey:
        """Get label from the entity"""

    @property
    def len(self) -> global___LengthKey:
        """Get length from the entity"""

    @property
    def all(self) -> global___AllKey:
        """Get all properties"""

    @property
    def key(self) -> common_pb2.NameOrId:
        """Get property of key from the entity"""

    def __init__(
        self,
        *,
        id: global___IdKey | None = ...,
        label: global___LabelKey | None = ...,
        len: global___LengthKey | None = ...,
        all: global___AllKey | None = ...,
        key: common_pb2.NameOrId | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["all", b"all", "id", b"id", "item", b"item", "key", b"key", "label", b"label", "len", b"len"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["all", b"all", "id", b"id", "item", b"item", "key", b"key", "label", b"label", "len", b"len"]) -> None: ...
    def WhichOneof(self, oneof_group: typing.Literal["item", b"item"]) -> typing.Literal["id", "label", "len", "all", "key"] | None: ...

global___Property = Property

@typing.final
class Variable(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    TAG_FIELD_NUMBER: builtins.int
    PROPERTY_FIELD_NUMBER: builtins.int
    NODE_TYPE_FIELD_NUMBER: builtins.int
    @property
    def tag(self) -> common_pb2.NameOrId:
        """The alias of a graph relation, which is required for a variable"""

    @property
    def property(self) -> global___Property:
        """The property of a nested attribute (vertex/edge) of a graph relation, r.a.key, optional"""

    @property
    def node_type(self) -> type_pb2.IrDataType:
        """The data of type of Property"""

    def __init__(
        self,
        *,
        tag: common_pb2.NameOrId | None = ...,
        property: global___Property | None = ...,
        node_type: type_pb2.IrDataType | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["node_type", b"node_type", "property", b"property", "tag", b"tag"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["node_type", b"node_type", "property", b"property", "tag", b"tag"]) -> None: ...

global___Variable = Variable

@typing.final
class VariableKeys(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    KEYS_FIELD_NUMBER: builtins.int
    @property
    def keys(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Variable]: ...
    def __init__(
        self,
        *,
        keys: collections.abc.Iterable[global___Variable] | None = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["keys", b"keys"]) -> None: ...

global___VariableKeys = VariableKeys

@typing.final
class VariableKeyValue(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    KEY_FIELD_NUMBER: builtins.int
    VAL_FIELD_NUMBER: builtins.int
    NESTED_FIELD_NUMBER: builtins.int
    @property
    def key(self) -> common_pb2.Value: ...
    @property
    def val(self) -> global___Variable: ...
    @property
    def nested(self) -> global___VariableKeyValues: ...
    def __init__(
        self,
        *,
        key: common_pb2.Value | None = ...,
        val: global___Variable | None = ...,
        nested: global___VariableKeyValues | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["key", b"key", "nested", b"nested", "val", b"val", "value", b"value"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["key", b"key", "nested", b"nested", "val", b"val", "value", b"value"]) -> None: ...
    def WhichOneof(self, oneof_group: typing.Literal["value", b"value"]) -> typing.Literal["val", "nested"] | None: ...

global___VariableKeyValue = VariableKeyValue

@typing.final
class VariableKeyValues(google.protobuf.message.Message):
    """A nested kv projection, which is used to project a nested structure of key-value pairs
    e.g., to project [value(a.name), value(a.age)], or project [key_value('name', a.name), key_value('age', a.age)],
    or more complex nested projection, 
    e.g., to project [key_value('tagA', nested{[key_value('name', a.name), key_value('age', a.age)]}), key_value('tagB', nested{key_value(b.name), key_value(b.age)})]
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    KEY_VALS_FIELD_NUMBER: builtins.int
    @property
    def key_vals(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___VariableKeyValue]: ...
    def __init__(
        self,
        *,
        key_vals: collections.abc.Iterable[global___VariableKeyValue] | None = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["key_vals", b"key_vals"]) -> None: ...

global___VariableKeyValues = VariableKeyValues

@typing.final
class DynamicParam(google.protobuf.message.Message):
    """dynamic param"""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    NAME_FIELD_NUMBER: builtins.int
    INDEX_FIELD_NUMBER: builtins.int
    DATA_TYPE_FIELD_NUMBER: builtins.int
    name: builtins.str
    index: builtins.int
    @property
    def data_type(self) -> type_pb2.IrDataType: ...
    def __init__(
        self,
        *,
        name: builtins.str = ...,
        index: builtins.int = ...,
        data_type: type_pb2.IrDataType | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["data_type", b"data_type"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["data_type", b"data_type", "index", b"index", "name", b"name"]) -> None: ...

global___DynamicParam = DynamicParam

@typing.final
class Case(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    @typing.final
    class WhenThen(google.protobuf.message.Message):
        """Pair of when <expr> then <expr>"""

        DESCRIPTOR: google.protobuf.descriptor.Descriptor

        WHEN_EXPRESSION_FIELD_NUMBER: builtins.int
        THEN_RESULT_EXPRESSION_FIELD_NUMBER: builtins.int
        @property
        def when_expression(self) -> global___Expression: ...
        @property
        def then_result_expression(self) -> global___Expression: ...
        def __init__(
            self,
            *,
            when_expression: global___Expression | None = ...,
            then_result_expression: global___Expression | None = ...,
        ) -> None: ...
        def HasField(self, field_name: typing.Literal["then_result_expression", b"then_result_expression", "when_expression", b"when_expression"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing.Literal["then_result_expression", b"then_result_expression", "when_expression", b"when_expression"]) -> None: ...

    WHEN_THEN_EXPRESSIONS_FIELD_NUMBER: builtins.int
    ELSE_RESULT_EXPRESSION_FIELD_NUMBER: builtins.int
    @property
    def when_then_expressions(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Case.WhenThen]:
        """A case operator always follows with a sequence of when_then pairs, e.g.
        CASE WHEN a.name == 'Marko' THEN 1
             WHEN a.name == 'John' THEN 2
        """

    @property
    def else_result_expression(self) -> global___Expression:
        """The trailed else expression:  ELSE 3"""

    def __init__(
        self,
        *,
        when_then_expressions: collections.abc.Iterable[global___Case.WhenThen] | None = ...,
        else_result_expression: global___Expression | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["else_result_expression", b"else_result_expression"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["else_result_expression", b"else_result_expression", "when_then_expressions", b"when_then_expressions"]) -> None: ...

global___Case = Case

@typing.final
class Extract(google.protobuf.message.Message):
    """extract interval from a given expression which should be of temporal type"""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    class _Interval:
        ValueType = typing.NewType("ValueType", builtins.int)
        V: typing_extensions.TypeAlias = ValueType

    class _IntervalEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[Extract._Interval.ValueType], builtins.type):
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
        YEAR: Extract._Interval.ValueType  # 0
        MONTH: Extract._Interval.ValueType  # 1
        DAY: Extract._Interval.ValueType  # 2
        HOUR: Extract._Interval.ValueType  # 3
        MINUTE: Extract._Interval.ValueType  # 4
        SECOND: Extract._Interval.ValueType  # 5
        MILLISECOND: Extract._Interval.ValueType  # 6

    class Interval(_Interval, metaclass=_IntervalEnumTypeWrapper): ...
    YEAR: Extract.Interval.ValueType  # 0
    MONTH: Extract.Interval.ValueType  # 1
    DAY: Extract.Interval.ValueType  # 2
    HOUR: Extract.Interval.ValueType  # 3
    MINUTE: Extract.Interval.ValueType  # 4
    SECOND: Extract.Interval.ValueType  # 5
    MILLISECOND: Extract.Interval.ValueType  # 6

    INTERVAL_FIELD_NUMBER: builtins.int
    interval: global___Extract.Interval.ValueType
    def __init__(
        self,
        *,
        interval: global___Extract.Interval.ValueType = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["interval", b"interval"]) -> None: ...

global___Extract = Extract

@typing.final
class TimeInterval(google.protobuf.message.Message):
    """denote time interval, i.e. 3 DAYS, 4 HOURS, 5 MINUTES"""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    INTERVAL_FIELD_NUMBER: builtins.int
    CONST_FIELD_NUMBER: builtins.int
    PARAM_FIELD_NUMBER: builtins.int
    interval: global___Extract.Interval.ValueType
    @property
    def const(self) -> common_pb2.Value: ...
    @property
    def param(self) -> global___DynamicParam: ...
    def __init__(
        self,
        *,
        interval: global___Extract.Interval.ValueType = ...,
        const: common_pb2.Value | None = ...,
        param: global___DynamicParam | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["const", b"const", "param", b"param", "value", b"value"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["const", b"const", "interval", b"interval", "param", b"param", "value", b"value"]) -> None: ...
    def WhichOneof(self, oneof_group: typing.Literal["value", b"value"]) -> typing.Literal["const", "param"] | None: ...

global___TimeInterval = TimeInterval

@typing.final
class DateTimeMinus(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    INTERVAL_FIELD_NUMBER: builtins.int
    interval: global___Extract.Interval.ValueType
    def __init__(
        self,
        *,
        interval: global___Extract.Interval.ValueType = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["interval", b"interval"]) -> None: ...

global___DateTimeMinus = DateTimeMinus

@typing.final
class Concat(google.protobuf.message.Message):
    """e.g., supposing p1 refers to [v1->v2->v3], p2 refers to [v3->v4->v5],
    then CONCAT(p1, p2) outputs [v1->v2->v3->v4->v5]
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    VARS_FIELD_NUMBER: builtins.int
    @property
    def vars(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Variable]: ...
    def __init__(
        self,
        *,
        vars: collections.abc.Iterable[global___Variable] | None = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["vars", b"vars"]) -> None: ...

global___Concat = Concat

@typing.final
class ExprOpr(google.protobuf.message.Message):
    """An operator of expression is one of Logical, Arithmetic, Const and Variable."""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    class _Brace:
        ValueType = typing.NewType("ValueType", builtins.int)
        V: typing_extensions.TypeAlias = ValueType

    class _BraceEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[ExprOpr._Brace.ValueType], builtins.type):
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
        LEFT_BRACE: ExprOpr._Brace.ValueType  # 0
        """("""
        RIGHT_BRACE: ExprOpr._Brace.ValueType  # 1
        """)"""

    class Brace(_Brace, metaclass=_BraceEnumTypeWrapper): ...
    LEFT_BRACE: ExprOpr.Brace.ValueType  # 0
    """("""
    RIGHT_BRACE: ExprOpr.Brace.ValueType  # 1
    """)"""

    LOGICAL_FIELD_NUMBER: builtins.int
    ARITH_FIELD_NUMBER: builtins.int
    CONST_FIELD_NUMBER: builtins.int
    VAR_FIELD_NUMBER: builtins.int
    BRACE_FIELD_NUMBER: builtins.int
    VARS_FIELD_NUMBER: builtins.int
    VAR_MAP_FIELD_NUMBER: builtins.int
    PARAM_FIELD_NUMBER: builtins.int
    CASE_FIELD_NUMBER: builtins.int
    EXTRACT_FIELD_NUMBER: builtins.int
    MAP_FIELD_NUMBER: builtins.int
    TIME_INTERVAL_FIELD_NUMBER: builtins.int
    DATE_TIME_MINUS_FIELD_NUMBER: builtins.int
    CONCAT_FIELD_NUMBER: builtins.int
    NODE_TYPE_FIELD_NUMBER: builtins.int
    logical: global___Logical.ValueType
    arith: global___Arithmetic.ValueType
    brace: global___ExprOpr.Brace.ValueType
    @property
    def const(self) -> common_pb2.Value: ...
    @property
    def var(self) -> global___Variable: ...
    @property
    def vars(self) -> global___VariableKeys: ...
    @property
    def var_map(self) -> global___VariableKeys: ...
    @property
    def param(self) -> global___DynamicParam:
        """dynamic param in expression"""

    @property
    def case(self) -> global___Case: ...
    @property
    def extract(self) -> global___Extract: ...
    @property
    def map(self) -> global___VariableKeyValues:
        """TODO: the new definition for var_map, that allows user-given key name, and nested maps. Will remove the old var_map finally."""

    @property
    def time_interval(self) -> global___TimeInterval: ...
    @property
    def date_time_minus(self) -> global___DateTimeMinus: ...
    @property
    def concat(self) -> global___Concat: ...
    @property
    def node_type(self) -> type_pb2.IrDataType:
        """The data of type of ExprOpr"""

    def __init__(
        self,
        *,
        logical: global___Logical.ValueType = ...,
        arith: global___Arithmetic.ValueType = ...,
        const: common_pb2.Value | None = ...,
        var: global___Variable | None = ...,
        brace: global___ExprOpr.Brace.ValueType = ...,
        vars: global___VariableKeys | None = ...,
        var_map: global___VariableKeys | None = ...,
        param: global___DynamicParam | None = ...,
        case: global___Case | None = ...,
        extract: global___Extract | None = ...,
        map: global___VariableKeyValues | None = ...,
        time_interval: global___TimeInterval | None = ...,
        date_time_minus: global___DateTimeMinus | None = ...,
        concat: global___Concat | None = ...,
        node_type: type_pb2.IrDataType | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["arith", b"arith", "brace", b"brace", "case", b"case", "concat", b"concat", "const", b"const", "date_time_minus", b"date_time_minus", "extract", b"extract", "item", b"item", "logical", b"logical", "map", b"map", "node_type", b"node_type", "param", b"param", "time_interval", b"time_interval", "var", b"var", "var_map", b"var_map", "vars", b"vars"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["arith", b"arith", "brace", b"brace", "case", b"case", "concat", b"concat", "const", b"const", "date_time_minus", b"date_time_minus", "extract", b"extract", "item", b"item", "logical", b"logical", "map", b"map", "node_type", b"node_type", "param", b"param", "time_interval", b"time_interval", "var", b"var", "var_map", b"var_map", "vars", b"vars"]) -> None: ...
    def WhichOneof(self, oneof_group: typing.Literal["item", b"item"]) -> typing.Literal["logical", "arith", "const", "var", "brace", "vars", "var_map", "param", "case", "extract", "map", "time_interval", "date_time_minus", "concat"] | None: ...

global___ExprOpr = ExprOpr

@typing.final
class Expression(google.protobuf.message.Message):
    """An inner representation of an expression"""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    OPERATORS_FIELD_NUMBER: builtins.int
    @property
    def operators(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___ExprOpr]: ...
    def __init__(
        self,
        *,
        operators: collections.abc.Iterable[global___ExprOpr] | None = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["operators", b"operators"]) -> None: ...

global___Expression = Expression
