---
title: ControlFlow
sidebarTitle: Welcome!
---

## What is ControlFlow?

**ControlFlow is a Python framework for building agentic AI workflows.**

<Note>
An **agentic workflow** is a process that delegates at least some of its work to an LLM agent. An agent is an autonomous entity that is invoked repeatedly to make decisions and perform complex tasks. To learn more, see the [AI glossary](/glossary/agentic-workflow).
</Note>


ControlFlow provides a structured, developer-focused framework for defining workflows and delegating work to LLMs, without sacrificing control or transparency:

- Create discrete, observable [tasks](/concepts/tasks) for an AI to solve.
- Assign one or more specialized AI [agents](/concepts/agents) to each task.
- Combine tasks into a [flow](/concepts/flows) to orchestrate more complex behaviors.



<CodeGroup>
```python Hello World
import controlflow as cf
from pydantic import BaseModel, Field


class Name(BaseModel):
    first: str = Field(min_length=1)
    last: str = Field(min_length=1)


@cf.flow
def demo():

    # - create a task to get the user's name as a `Name` object
    # - run the task eagerly with ad-hoc instructions
    # - validate that the response was not 'Marvin'

    name_task = cf.Task("Get the user's name", result_type=Name, user_access=True)
    
    with cf.instructions("Talk like a pirate!"):
        name_task.run()

    if name_task.result.first == 'Marvin':
        raise ValueError("Hey, that's my name!")


    # - create a custom agent that loves limericks
    # - have the agent write a poem
    # - indicate that the poem depends on the name from the previous task

    poetry_bot = cf.Agent(name="poetry-bot", instructions="you love limericks")

    poem_task = cf.Task(
        "Write a poem about AI workflows, based on the user's name",
        agents=[poetry_bot],
        context={"name": name_task},
    )
    
    return poem_task


if __name__ == "__main__":
    print(demo())
```
```python Restaurant recommendations
import controlflow as cf
from pydantic import BaseModel


class Preferences(BaseModel):
    location: str
    cuisine: str


class Restaurant(BaseModel):
    name: str
    description: str


@cf.flow
def restaurant_recommendations(n:int) -> list[Restaurant]:
    """
    An agentic workflow that asks the user for preferences, 
    then recommends restaurants based on their input.
    """
    
    # get preferences from the user
    preferences = cf.Task(
        "Get the user's preferences", 
        result_type=Preferences, 
        user_access=True,
    )
    
    # generate the recommendations
    recommendations = cf.Task(
        f"Recommend {n} restaurants to the user", 
        context=dict(preferences=preferences),
        result_type=list[Restaurant], 
    )

    return recommendations


if __name__ == "__main__":
    print(restaurant_recommendations(n=3))
```
</CodeGroup>

## Why ControlFlow?

The goal of this framework is to let you build AI workflows with confidence. 

ControlFlow's design reflects the opinion that AI agents are most effective when given clear, well-defined tasks and constraints. By breaking down complex goals into manageable tasks that can be composed into a larger workflow, we can harness the power of AI while maintaining precise control over its overall direction and outcomes.

At the core of every agentic workflow is a loop that repeatedly invokes an LLM to make progress towards a goal. At every step of this loop, ControlFlow lets you continuously tune how much autonomy your agents have. This allows you to strategically balance control and autonomy throughout the workflow, ensuring that the AI's actions align closely with your objectives while still leveraging its creative capabilities. For some tasks, you may provide specific, constrained instructions; for others, you can give the AI more open-ended goals.

ControlFlow provides the tools and abstractions to help you find this balance, letting you build agentic workflows tailored to your specific needs and objectives. You can delegate only as much - or as little - work to your agents as you need, while maintaining full visibility and control over the entire process. 

These objectives lead to a few key design principles that underpin ControlFlow's architecture:


### üõ†Ô∏è Simple Over Complex

ControlFlow allows you to deploy specialized LLMs to a series of small problems, rather than use a monolithic model that tries to do everything. These single-serving LLMs are more effective and efficient, ensuring that each task is handled by the right tool, with the right context, leading to higher-quality results.

Get started by creating a specialized [agent](/concepts/agents) or writing a discrete [task](/concepts/tasks).


### üéØ Outcome Over Process

ControlFlow takes a declarative approach to defining AI workflows. By focusing on outcomes instead of attempting to steer every action and decision of the LLM, you can create more predictable and controllable workflows, making it easier to achieve your goals.

Get started by defining your [tasks](/concepts/tasks) and composing them into [flows](/concepts/flows).

### ‚å®Ô∏è Code Over Chat

ControlFlow helps you automate AI-powered workflows with confidence. While your workflows may involve human conversations, ControlFlow is code first, chat second. That means that even when your agents talk to a user, the artifacts of your workflow are always structured data, not a list of messages. This makes it easier to debug, monitor, and maintain your AI-enhanced applications.

### ü¶æ Control Over Autonomy

ControlFlow is designed to give you control over your AI workflows, but the power of AI agents often comes from their autonomy. The framework finds a balance between these two ideas by using tasks to define the scope and constraints of any work that you delegate to your agents. This allows you to choose exactly when and how much autonomy to give to your agents, ensuring that they operate within the boundaries you set.

## Key Features

ControlFlow's design principles lead to a number of key features that make it a powerful tool for building AI-powered applications:

### üß© Task-Centric Design

ControlFlow breaks down AI workflows into discrete, self-contained tasks, each with a specific objective and set of requirements. This declarative, modular approach lets you focus on the high-level logic of your applications while allowing the framework to manage the details of coordinating agents and data flow between tasks.

### üïµÔ∏è Agent Orchestration

ControlFlow's orchestration engine coordinates your agents, assigning tasks to the most appropriate models and managing the flow of data between them, while maintaining consistent context and history. The engine uses knowledge of the entire workflow to optimize agent instructions and ensure that every task contributes to the overall goal of the workflow.

### üîç Native Debugging and Observability

ControlFlow prioritizes transparency and ease of debugging by providing native tools for monitoring and inspecting the execution of AI tasks. You can easily track the progress of your workflows, identify bottlenecks or issues, and gain insights into the behavior of individual agents, ensuring that your AI applications are functioning as intended.

### ü§ù Seamless Integration

ControlFlow is designed to integrate seamlessly with any Python script or codebase, elevating AI tasks to first-class citizens in your application logic. You can build end-to-end AI workflows, or only delegate a single step of a large process to an AI. This allows for gradual and controlled adoption of AI agents, reducing the risk and complexity of introducing AI into existing systems.

Together, these features make ControlFlow a powerful and flexible framework for building AI-powered applications that are transparent, maintainable, and aligned with software engineering best practices.
