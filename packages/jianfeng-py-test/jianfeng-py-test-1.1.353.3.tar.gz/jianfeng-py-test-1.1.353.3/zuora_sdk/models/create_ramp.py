# coding: utf-8

"""
    Zuora API Reference

    REST API reference for the Zuora Billing, Payments, and Central Platform! Check out the [REST API Overview](https://www.zuora.com/developer/api-references/api/overview/).

    The version of the OpenAPI document: 2023-10-24
    Contact: docs@zuora.com
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json


from typing import List, Optional
from pydantic import BaseModel, Field, StrictBool, StrictStr, conlist
from zuora_sdk.models.ramp_charge_request import RampChargeRequest
from zuora_sdk.models.ramp_interval_request import RampIntervalRequest

class CreateRamp(BaseModel):
    """
    Container of the ramp definitions. It is used to create, update, or remove the ramp definition for the new subscription.   # noqa: E501
    """
    charges: Optional[conlist(RampChargeRequest)] = Field(None, description="Container for the rate plan charges that are considered as part of the ramp deal.  * If this field is not specified, all the one-time and recurring regular charges of the new subscription are automatically considered as part of the ramp deal. * If this field is specified, either 'chargeNumber' or 'uniqueToken' must be specified. ")
    delete: Optional[StrictBool] = Field(None, description="Whether to remove the ramp definition from the new subscription. If you want to remove the ramp definition, this field is the only required field for the `ramp` object.   ")
    description: Optional[StrictStr] = Field(None, description="The short description of the ramp.")
    intervals: Optional[conlist(RampIntervalRequest)] = Field(None, description="Container for the intervals that the ramp is split into in its timeline.   It is required when you want to create or update the ramp definition. The ramp intervals cannot have any overlap or gap between each other. ")
    name: Optional[StrictStr] = Field(None, description="The name of the ramp.")
    __properties = ["charges", "delete", "description", "intervals", "name"]

    class Config:
        """Pydantic configuration"""
        allow_population_by_field_name = True
        validate_assignment = True

    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.dict(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> CreateRamp:
        """Create an instance of CreateRamp from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self):
        """Returns the dictionary representation of the model using alias"""
        _dict = self.dict(by_alias=True,
                          exclude={
                          },
                          exclude_none=True)
        # override the default output from pydantic by calling `to_dict()` of each item in charges (list)
        _items = []
        if self.charges:
            for _item in self.charges:
                if _item:
                    _items.append(_item.to_dict())
            _dict['charges'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in intervals (list)
        _items = []
        if self.intervals:
            for _item in self.intervals:
                if _item:
                    _items.append(_item.to_dict())
            _dict['intervals'] = _items
        return _dict

    @classmethod
    def from_dict(cls, obj: dict) -> CreateRamp:
        """Create an instance of CreateRamp from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return CreateRamp.parse_obj(obj)

        _obj = CreateRamp.parse_obj({
            "charges": [RampChargeRequest.from_dict(_item) for _item in obj.get("charges")] if obj.get("charges") is not None else None,
            "delete": obj.get("delete"),
            "description": obj.get("description"),
            "intervals": [RampIntervalRequest.from_dict(_item) for _item in obj.get("intervals")] if obj.get("intervals") is not None else None,
            "name": obj.get("name")
        })
        return _obj


