# coding: utf-8

"""
    Zuora API Reference

    REST API reference for the Zuora Billing, Payments, and Central Platform! Check out the [REST API Overview](https://www.zuora.com/developer/api-references/api/overview/).

    The version of the OpenAPI document: 2023-10-24
    Contact: docs@zuora.com
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json


from typing import List, Optional
from pydantic import BaseModel, Field, conlist
from com.zuora.models.charge_model_configuration_for_subscription import ChargeModelConfigurationForSubscription
from com.zuora.models.charge_tier import ChargeTier

class OrderActionRatePlanChargeModelDataOverride(BaseModel):
    """
    Container for charge model configuration data.  **Note**: This field is only available if you have the High Water Mark, Pre-Rated Pricing, or Multi-Attribute Pricing charge models enabled. The charge models are available for customers with Enterprise and Nine editions by default. If you are a Growth customer, see [Zuora Editions](https://knowledgecenter.zuora.com/BB_Introducing_Z_Business/C_Zuora_Editions) for pricing information.   # noqa: E501
    """
    charge_model_configuration: Optional[ChargeModelConfigurationForSubscription] = Field(None, alias="chargeModelConfiguration")
    tiers: Optional[conlist(ChargeTier)] = Field(None, description="List of cumulative pricing tiers in the charge.  **Note**: When you override tiers of the charge with a High Water Mark Pricing charge model, you have to provide all of the tiers, including the ones you do not want to change. The new tiers will completely override the previous ones. The High Water Mark Pricing charge models are available for customers with Enterprise and Nine editions by default. If you are a Growth customer, see [Zuora Editions](https://knowledgecenter.zuora.com/BB_Introducing_Z_Business/C_Zuora_Editions) for pricing information. ")
    __properties = ["chargeModelConfiguration", "tiers"]

    class Config:
        """Pydantic configuration"""
        allow_population_by_field_name = True
        validate_assignment = True

    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.dict(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> OrderActionRatePlanChargeModelDataOverride:
        """Create an instance of OrderActionRatePlanChargeModelDataOverride from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self):
        """Returns the dictionary representation of the model using alias"""
        _dict = self.dict(by_alias=True,
                          exclude={
                          },
                          exclude_none=True)
        # override the default output from pydantic by calling `to_dict()` of charge_model_configuration
        if self.charge_model_configuration:
            _dict['chargeModelConfiguration'] = self.charge_model_configuration.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each item in tiers (list)
        _items = []
        if self.tiers:
            for _item in self.tiers:
                if _item:
                    _items.append(_item.to_dict())
            _dict['tiers'] = _items
        return _dict

    @classmethod
    def from_dict(cls, obj: dict) -> OrderActionRatePlanChargeModelDataOverride:
        """Create an instance of OrderActionRatePlanChargeModelDataOverride from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return OrderActionRatePlanChargeModelDataOverride.parse_obj(obj)

        _obj = OrderActionRatePlanChargeModelDataOverride.parse_obj({
            "charge_model_configuration": ChargeModelConfigurationForSubscription.from_dict(obj.get("chargeModelConfiguration")) if obj.get("chargeModelConfiguration") is not None else None,
            "tiers": [ChargeTier.from_dict(_item) for _item in obj.get("tiers")] if obj.get("tiers") is not None else None
        })
        return _obj


