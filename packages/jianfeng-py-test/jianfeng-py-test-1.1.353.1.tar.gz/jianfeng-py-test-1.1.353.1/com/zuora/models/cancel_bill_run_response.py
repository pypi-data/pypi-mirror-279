# coding: utf-8

"""
    Zuora API Reference

    REST API reference for the Zuora Billing, Payments, and Central Platform! Check out the [REST API Overview](https://www.zuora.com/developer/api-references/api/overview/).

    The version of the OpenAPI document: 2023-10-24
    Contact: docs@zuora.com
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from datetime import date
from typing import List, Optional
from pydantic import BaseModel, Field, StrictBool, StrictInt, StrictStr, conint, conlist
from com.zuora.models.bill_run import BillRun
from com.zuora.models.bill_run_filter import BillRunFilter
from com.zuora.models.bill_run_schedule import BillRunSchedule
from com.zuora.models.bill_run_status import BillRunStatus
from com.zuora.models.charge_type import ChargeType
from com.zuora.models.failed_reason import FailedReason

class CancelBillRunResponse(BaseModel):
    """
    CancelBillRunResponse
    """
    process_id: Optional[StrictStr] = Field(None, alias="processId", description="The Id of the process that handle the operation. ")
    request_id: Optional[StrictStr] = Field(None, alias="requestId", description="Unique request identifier. If you need to contact us about a specific request, providing the request identifier will ensure the fastest possible resolution. ")
    reasons: Optional[conlist(FailedReason)] = None
    success: Optional[StrictBool] = Field(None, description="Indicates whether the call succeeded. ")
    id: Optional[StrictStr] = Field(None, description="The unique ID of the bill run. ")
    name: Optional[StrictStr] = Field(None, description="The name of the bill run. ")
    bill_run_number: Optional[StrictStr] = Field(None, alias="billRunNumber", description="The number of the bill run. ")
    batches: Optional[conlist(StrictStr)] = Field(None, description="The batch of accounts for this bill run, this field can not exist with `billRunFilters` together.  **Values:** `AllBatches` or an array of `Batch`*n* where *n* is a number between 1 and 50, for example, `Batch7`. ")
    bill_cycle_day: Optional[StrictStr] = Field(None, alias="billCycleDay", description="The day of the bill cycle, this field is only valid when `batches` is specified.  **Values:**  - `AllBillCycleDays` or one of numbers 1 - 31 for an ad-hoc bill run - `AllBillCycleDays`, one of numbers 1 - 31, or `AsRunDay` for a scheduled bill run ")
    bill_run_filters: Optional[conlist(BillRunFilter)] = Field(None, alias="billRunFilters", description="The target account or subscriptions for this bill run. ")
    charge_type_to_exclude: Optional[conlist(StrictStr)] = Field(None, alias="chargeTypeToExclude", description="The types of the charges to be excluded from the generation of billing documents. ")
    auto_email: Optional[StrictBool] = Field(None, alias="autoEmail", description="Whether to automatically send emails after Auto-Post is complete. ")
    auto_post: Optional[StrictBool] = Field(None, alias="autoPost", description="Whether to automatically post the bill run after the bill run is created. ")
    auto_renewal: Optional[StrictBool] = Field(None, alias="autoRenewal", description="Whether to automatically renew auto-renew subscriptions that are up for renewal. ")
    no_email_for_zero_amount_invoice: Optional[StrictBool] = Field(None, alias="noEmailForZeroAmountInvoice", description="Whether to suppress emails for invoices with zero total amount generated in this bill run after the bill run is complete. ")
    schedule: Optional[BillRunSchedule] = None
    scheduled_execution_time: Optional[StrictStr] = Field(None, alias="scheduledExecutionTime", description="The scheduled execution time for a bill run. ")
    status: Optional[StrictStr] = None
    invoice_date: Optional[date] = Field(None, alias="invoiceDate", description="The invoice date for this bill run, only valid for ad-hoc bill runs. ")
    invoice_date_offset: Optional[StrictInt] = Field(None, alias="invoiceDateOffset", description="The offset compared to bill run execution date, only valid for scheduled bill runs. ")
    invoice_date_month_offset: Optional[StrictInt] = Field(None, alias="invoiceDateMonthOffset", description="The month offset of invoice date for this bill run based on run date, only valid for monthly scheduled bill runs. invoiceDateOffset and invoiceDateMonthOffset/invoiceDateDayOfMonth are mutually exclusive. invoiceDateMonthOffset and invoiceDateDayOfMonth coexist. ")
    invoice_date_day_of_month: Optional[conint(strict=True, le=31, ge=1)] = Field(None, alias="invoiceDateDayOfMonth", description="The day of month of invoice date for this bill run, only valid for monthly scheduled bill runs. The value is between 1 and 31, where 31 = end-of-month. invoiceDateOffset and invoiceDateMonthOffset/invoiceDateDayOfMonth are mutually exclusive. invoiceDateMonthOffset and invoiceDateDayOfMonth coexist. ")
    target_date: Optional[date] = Field(None, alias="targetDate", description="The target date for this bill run, only valid for ad-hoc bill runs. ")
    target_date_offset: Optional[StrictInt] = Field(None, alias="targetDateOffset", description="The offset compared to bill run execution date, only valid for scheduled bill runs. ")
    target_date_month_offset: Optional[StrictInt] = Field(None, alias="targetDateMonthOffset", description="The month offset of target date for this bill run based on run date, only valid for monthly scheduled bill runs. targetDateOffset and targetDateMonthOffset/targetDateDayOfMonth are mutually exclusive. targetDateMonthOffset and targetDateDayOfMonth coexist. ")
    target_date_day_of_month: Optional[conint(strict=True, le=31, ge=1)] = Field(None, alias="targetDateDayOfMonth", description="The day of month of target date for this bill run, only valid for monthly scheduled bill runs. The value is between 1 and 31, where 31 = end-of-month. targetDateOffset and targetDateMonthOffset/targetDateDayOfMonth are mutually exclusive. targetDateMonthOffset and targetDateDayOfMonth coexist. ")
    created_by_id: Optional[StrictStr] = Field(None, alias="createdById", description="The ID of the user who created the bill run. ")
    created_date: Optional[StrictStr] = Field(None, alias="createdDate", description="The date and time when the bill run was created. ")
    updated_by_id: Optional[StrictStr] = Field(None, alias="updatedById", description="The ID of the user who last updated the bill run. ")
    updated_date: Optional[StrictStr] = Field(None, alias="updatedDate", description="The date and time when the bill run was last updated. ")
    next_run: Optional[BillRun] = Field(None, alias="nextRun")
    __properties = ["processId", "requestId", "reasons", "success", "id", "name", "billRunNumber", "batches", "billCycleDay", "billRunFilters", "chargeTypeToExclude", "autoEmail", "autoPost", "autoRenewal", "noEmailForZeroAmountInvoice", "schedule", "scheduledExecutionTime", "status", "invoiceDate", "invoiceDateOffset", "invoiceDateMonthOffset", "invoiceDateDayOfMonth", "targetDate", "targetDateOffset", "targetDateMonthOffset", "targetDateDayOfMonth", "createdById", "createdDate", "updatedById", "updatedDate", "nextRun"]

    class Config:
        """Pydantic configuration"""
        allow_population_by_field_name = True
        validate_assignment = True

    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.dict(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> CancelBillRunResponse:
        """Create an instance of CancelBillRunResponse from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self):
        """Returns the dictionary representation of the model using alias"""
        _dict = self.dict(by_alias=True,
                          exclude={
                          },
                          exclude_none=True)
        # override the default output from pydantic by calling `to_dict()` of each item in reasons (list)
        _items = []
        if self.reasons:
            for _item in self.reasons:
                if _item:
                    _items.append(_item.to_dict())
            _dict['reasons'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in bill_run_filters (list)
        _items = []
        if self.bill_run_filters:
            for _item in self.bill_run_filters:
                if _item:
                    _items.append(_item.to_dict())
            _dict['billRunFilters'] = _items
        # override the default output from pydantic by calling `to_dict()` of schedule
        if self.schedule:
            _dict['schedule'] = self.schedule.to_dict()
        # override the default output from pydantic by calling `to_dict()` of next_run
        if self.next_run:
            _dict['nextRun'] = self.next_run.to_dict()
        return _dict

    @classmethod
    def from_dict(cls, obj: dict) -> CancelBillRunResponse:
        """Create an instance of CancelBillRunResponse from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return CancelBillRunResponse.parse_obj(obj)

        _obj = CancelBillRunResponse.parse_obj({
            "process_id": obj.get("processId"),
            "request_id": obj.get("requestId"),
            "reasons": [FailedReason.from_dict(_item) for _item in obj.get("reasons")] if obj.get("reasons") is not None else None,
            "success": obj.get("success"),
            "id": obj.get("id"),
            "name": obj.get("name"),
            "bill_run_number": obj.get("billRunNumber"),
            "batches": obj.get("batches"),
            "bill_cycle_day": obj.get("billCycleDay"),
            "bill_run_filters": [BillRunFilter.from_dict(_item) for _item in obj.get("billRunFilters")] if obj.get("billRunFilters") is not None else None,
            "charge_type_to_exclude": obj.get("chargeTypeToExclude"),
            "auto_email": obj.get("autoEmail"),
            "auto_post": obj.get("autoPost"),
            "auto_renewal": obj.get("autoRenewal"),
            "no_email_for_zero_amount_invoice": obj.get("noEmailForZeroAmountInvoice"),
            "schedule": BillRunSchedule.from_dict(obj.get("schedule")) if obj.get("schedule") is not None else None,
            "scheduled_execution_time": obj.get("scheduledExecutionTime"),
            "status": obj.get("status"),
            "invoice_date": obj.get("invoiceDate"),
            "invoice_date_offset": obj.get("invoiceDateOffset"),
            "invoice_date_month_offset": obj.get("invoiceDateMonthOffset"),
            "invoice_date_day_of_month": obj.get("invoiceDateDayOfMonth"),
            "target_date": obj.get("targetDate"),
            "target_date_offset": obj.get("targetDateOffset"),
            "target_date_month_offset": obj.get("targetDateMonthOffset"),
            "target_date_day_of_month": obj.get("targetDateDayOfMonth"),
            "created_by_id": obj.get("createdById"),
            "created_date": obj.get("createdDate"),
            "updated_by_id": obj.get("updatedById"),
            "updated_date": obj.get("updatedDate"),
            "next_run": BillRun.from_dict(obj.get("nextRun")) if obj.get("nextRun") is not None else None
        })
        return _obj


