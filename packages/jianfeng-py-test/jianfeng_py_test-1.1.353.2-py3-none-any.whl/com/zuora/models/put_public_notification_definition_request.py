# coding: utf-8

"""
    Zuora API Reference

    REST API reference for the Zuora Billing, Payments, and Central Platform! Check out the [REST API Overview](https://www.zuora.com/developer/api-references/api/overview/).

    The version of the OpenAPI document: 2023-10-24
    Contact: docs@zuora.com
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json


from typing import Dict, Optional
from pydantic import BaseModel, Field, StrictBool, StrictStr, constr
from com.zuora.models.put_public_notification_definition_request_callout import PutPublicNotificationDefinitionRequestCallout
from com.zuora.models.put_public_notification_definition_request_filter_rule import PutPublicNotificationDefinitionRequestFilterRule

class PutPublicNotificationDefinitionRequest(BaseModel):
    """
    PutPublicNotificationDefinitionRequest
    """
    active: Optional[StrictBool] = Field(True, description="The status of the notification definition. The default value is `true`.")
    associated_account: Optional[StrictStr] = Field(None, alias="associatedAccount", description="Indicates with which type of account this notification is associated. Depending on your environment, you can use one of the following values: * `Account.Id`: ID of the primary customer account related to the notification. It is also the default value. * `ParentAccount.Id`: this option is available only if you have <a href=\"https://knowledgecenter.zuora.com/Billing/Subscriptions/Customer_Accounts/A_Customer_Account_Introduction#Customer_Hierarchy\" target=\"_blank\">Customer Hierarchy</a> enabled for your tenant. * `SubscriptionOwnerAccount.Id`: this option is available if the base object of the notification is Order Action.  **Note:** before specifying this field, we recommend that you use [Data Source](https://knowledgecenter.zuora.com/Billing/Reporting/D_Data_Sources_and_Exports/C_Data_Source_Reference) to check the available types of accounts for the current notification.   ")
    callout: Optional[PutPublicNotificationDefinitionRequestCallout] = None
    callout_active: Optional[StrictBool] = Field(False, alias="calloutActive", description="The status of the callout action. The default value is `false`.")
    communication_profile_id: Optional[StrictStr] = Field(None, alias="communicationProfileId", description="The profile that notification definition belongs to. If you want to update the notification to a system notification, you should pass 'SystemNotification'. ' ")
    description: Optional[constr(strict=True, max_length=255)] = Field(None, description="The description of the notification definition.")
    email_active: Optional[StrictBool] = Field(False, alias="emailActive", description="The status of the email action. The default value is `false`.")
    email_template_id: Optional[StrictStr] = Field(None, alias="emailTemplateId", description="The ID of the email template. If emailActive is updated from false to true, an email template is required, and the EventType of the email template MUST be the same as the EventType of the notification definition. ")
    filter_rule: Optional[PutPublicNotificationDefinitionRequestFilterRule] = Field(None, alias="filterRule")
    filter_rule_params: Optional[Dict[str, StrictStr]] = Field(None, alias="filterRuleParams", description="The parameter values used to configure the filter rule. ")
    name: Optional[constr(strict=True, max_length=255)] = Field(None, description="The name of the notification definition, which is unique in the profile.")
    __properties = ["active", "associatedAccount", "callout", "calloutActive", "communicationProfileId", "description", "emailActive", "emailTemplateId", "filterRule", "filterRuleParams", "name"]

    class Config:
        """Pydantic configuration"""
        allow_population_by_field_name = True
        validate_assignment = True

    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.dict(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> PutPublicNotificationDefinitionRequest:
        """Create an instance of PutPublicNotificationDefinitionRequest from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self):
        """Returns the dictionary representation of the model using alias"""
        _dict = self.dict(by_alias=True,
                          exclude={
                          },
                          exclude_none=True)
        # override the default output from pydantic by calling `to_dict()` of callout
        if self.callout:
            _dict['callout'] = self.callout.to_dict()
        # override the default output from pydantic by calling `to_dict()` of filter_rule
        if self.filter_rule:
            _dict['filterRule'] = self.filter_rule.to_dict()
        return _dict

    @classmethod
    def from_dict(cls, obj: dict) -> PutPublicNotificationDefinitionRequest:
        """Create an instance of PutPublicNotificationDefinitionRequest from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return PutPublicNotificationDefinitionRequest.parse_obj(obj)

        _obj = PutPublicNotificationDefinitionRequest.parse_obj({
            "active": obj.get("active") if obj.get("active") is not None else True,
            "associated_account": obj.get("associatedAccount"),
            "callout": PutPublicNotificationDefinitionRequestCallout.from_dict(obj.get("callout")) if obj.get("callout") is not None else None,
            "callout_active": obj.get("calloutActive") if obj.get("calloutActive") is not None else False,
            "communication_profile_id": obj.get("communicationProfileId"),
            "description": obj.get("description"),
            "email_active": obj.get("emailActive") if obj.get("emailActive") is not None else False,
            "email_template_id": obj.get("emailTemplateId"),
            "filter_rule": PutPublicNotificationDefinitionRequestFilterRule.from_dict(obj.get("filterRule")) if obj.get("filterRule") is not None else None,
            "filter_rule_params": obj.get("filterRuleParams"),
            "name": obj.get("name")
        })
        return _obj


