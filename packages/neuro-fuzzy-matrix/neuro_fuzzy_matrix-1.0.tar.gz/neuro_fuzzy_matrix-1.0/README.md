Библиотека предназначена для работы с нечеткой логикой с использованием матричного вывода, а также обучения сети по обучающему множеству, где в ходе обучения будут изменены графики принадлежности для входных ЛП.


Задаем объект класса NFM, который будет далее полностью описывать нашу систему.

ts = np.loadtxt(file_path, usecols=[0,1,2])
X = ts[:,0:2]
Y = ts[:,2]
nfm = NFM(X, Y)
Для работы доступны два способа задания выходных параметров, Simple - упрощенный, задание центров фигур для термов выходной переменной, Centroid - задание графиков принадлежности.

nfm.defuzzification = "Simple"
Для создания признака или лингвистической переменной выбираем метод create_feature и передаем ему 5 параметров: строковое значение с названием ЛП, строковое значение со системой измерения, значение типа float для указания ми-нимального значения, значение типа float для указания максимального значения и логического значение, где true – входная переменная, а false – выходная.

AT = nfm.create_feature("Температура", "C", 0, 38, True)
V = nfm.create_feature("Разрежение выхлопных газов", "cm Hg", 25, 82, True)
PE = nfm.create_feature("Генерация электроэнергии", "MW", 430, 510, False)

Для создания предиката или терма лингвистической переменной нужно выбрать метод create_ predicate и передать ему 3 параметра: лингвистическая переменная, которой принадлежит терм, строковое значение с названием терма, функцию принадлежности. Доступно три функции принадлежности: гауссовская Gauss, треугольная , трапециевидная, и . 

p_AT_low = nfm.create_predicate(AT, 'Низкая', func=Points, params=[[0, 0], [4, 1], [9, 1]])
p_AT_normal1 = nfm.create_predicate(AT, 'Средняя1', func=Points, params=[[8, 0], [15, 1], [20, 0]])
p_AT_normal2 = nfm.create_predicate(AT, 'Средняя2', func=Points, params=[[17, 0], [20, 1], [23, 0]])
p_AT_high = nfm.create_predicate(AT, 'Высокая', func=Points, params=[[22, 0], [30, 1], [38, 0]])

p_V_normal = nfm.create_predicate(V, 'Среднее', func=Points, params=[[25, 0], [40, 1], [70, 0]])
p_V_high = nfm.create_predicate(V, 'Высокое', func=Points, params=[[60, 0], [70, 1], [82, 0]])

p_PE_450 = nfm.create_predicate(PE, 'Низкая', const=450)
p_PE_460 = nfm.create_predicate(PE, 'Средняя1', const=460)
p_PE_470 = nfm.create_predicate(PE, 'Средняя2', const=470)
p_PE_490= nfm.create_predicate(PE, 'Высокая1', const=490)
p_PE_500= nfm.create_predicate(PE, 'Высокая2', const=500)

Для задания правил нужно выбрать метод create_rule и передать ему список условий, заключение и вес правила. Условия в правиле соединены между собой связкой “и”, поэтому если в правиле присутствует связка “или”, правило следует разбить на несколько правил.

r_1 = nfm.create_rule([p_AT_low], p_PE_500, 1)
r_2 = nfm.create_rule([p_AT_normal1], p_PE_490, 1)
r_3 = nfm.create_rule([p_AT_normal2, p_V_normal], p_PE_470, 1)
r_4 = nfm.create_rule([p_AT_normal2, p_V_high], p_PE_460, 1)
r_5 = nfm.create_rule([p_AT_high, p_V_normal], p_PE_460, 1)
r_6 = nfm.create_rule([p_AT_high, p_V_high], p_PE_450, 1)

Для обучения нейросети нужно вызвать метод trein, передав ему необходимые параметры, это может быть количество эпох обучения, точность ошибки, шаг для градиентного спуска.

nfm.train(epochs=5, k=0.1)

Для вывода графика ошибки вызывается метод show_errors, для вывода графиков принадлежности функций нужно вызвать метод show_view.

nfm.show_errors()
nfm.show_view()

