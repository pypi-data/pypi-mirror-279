# This file was auto-generated by Fern from our API Definition.

import typing
import urllib.parse
from json.decoder import JSONDecodeError

from ..core.api_error import ApiError
from ..core.client_wrapper import AsyncClientWrapper, SyncClientWrapper
from ..core.jsonable_encoder import jsonable_encoder
from ..core.pydantic_utilities import pydantic_v1
from ..core.remove_none_from_dict import remove_none_from_dict
from ..core.request_options import RequestOptions
from .errors.unprocessable_entity_error import UnprocessableEntityError
from .types.asset_type import AssetType
from .types.base_engine import BaseEngine
from .types.base_engine_type import BaseEngineType
from .types.complete_asset_upload_response import CompleteAssetUploadResponse
from .types.create_asset_response import CreateAssetResponse
from .types.data import Data
from .types.data_type import DataType
from .types.delete_asset_response import DeleteAssetResponse
from .types.http_validation_error import HttpValidationError
from .types.list_assets_response import ListAssetsResponse
from .types.retrieve_asset_response import RetrieveAssetResponse
from .types.transfer_api_type import TransferApiType

# this is used as the default value for optional parameters
OMIT = typing.cast(typing.Any, ...)


class AssetLibraryClient:
    def __init__(self, *, client_wrapper: SyncClientWrapper):
        self._client_wrapper = client_wrapper

    def list(
        self,
        *,
        name: typing.Optional[str] = None,
        is_public: typing.Optional[bool] = None,
        data_type: typing.Optional[DataType] = None,
        asset_type: typing.Optional[typing.Union[AssetType, typing.Sequence[AssetType]]] = None,
        engine: typing.Optional[typing.Union[BaseEngine, typing.Sequence[BaseEngine]]] = None,
        engine_type: typing.Optional[BaseEngineType] = None,
        limit: typing.Optional[int] = None,
        offset: typing.Optional[int] = None,
        get_preview_urls: typing.Optional[bool] = None,
        asset_ids: typing.Optional[str] = None,
        owner: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> ListAssetsResponse:
        """
        Parameters
        ----------
        name : typing.Optional[str]

        is_public : typing.Optional[bool]

        data_type : typing.Optional[DataType]

        asset_type : typing.Optional[typing.Union[AssetType, typing.Sequence[AssetType]]]

        engine : typing.Optional[typing.Union[BaseEngine, typing.Sequence[BaseEngine]]]

        engine_type : typing.Optional[BaseEngineType]

        limit : typing.Optional[int]

        offset : typing.Optional[int]

        get_preview_urls : typing.Optional[bool]

        asset_ids : typing.Optional[str]

        owner : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        ListAssetsResponse
            Successful Response

        Examples
        --------
        from octoai.client import OctoAI

        client = OctoAI(
            api_key="YOUR_API_KEY",
        )
        client.asset_library.list()
        """
        _response = self._client_wrapper.httpx_client.request(
            method="GET",
            url=urllib.parse.urljoin(f"{self._client_wrapper.get_environment().default}/", "v1/assets"),
            params=jsonable_encoder(
                remove_none_from_dict(
                    {
                        "name": name,
                        "is_public": is_public,
                        "data_type": data_type,
                        "asset_type": asset_type,
                        "engine": engine,
                        "engine_type": engine_type,
                        "limit": limit,
                        "offset": offset,
                        "get_preview_urls": get_preview_urls,
                        "asset_ids": asset_ids,
                        "owner": owner,
                        **(
                            request_options.get("additional_query_parameters", {})
                            if request_options is not None
                            else {}
                        ),
                    }
                )
            ),
            headers=jsonable_encoder(
                remove_none_from_dict(
                    {
                        **self._client_wrapper.get_headers(),
                        **(request_options.get("additional_headers", {}) if request_options is not None else {}),
                    }
                )
            ),
            timeout=request_options.get("timeout_in_seconds")
            if request_options is not None and request_options.get("timeout_in_seconds") is not None
            else self._client_wrapper.get_timeout(),
            retries=0,
            max_retries=request_options.get("max_retries") if request_options is not None else 0,  # type: ignore
        )
        if 200 <= _response.status_code < 300:
            return pydantic_v1.parse_obj_as(ListAssetsResponse, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(
                pydantic_v1.parse_obj_as(HttpValidationError, _response.json())  # type: ignore
            )
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def create(
        self,
        *,
        asset_type: AssetType,
        data: Data,
        name: str,
        description: typing.Optional[str] = OMIT,
        hf_repo: typing.Optional[str] = OMIT,
        hf_token_secret: typing.Optional[str] = OMIT,
        is_public: typing.Optional[bool] = OMIT,
        skip_validation: typing.Optional[bool] = OMIT,
        transfer_api_type: typing.Optional[TransferApiType] = OMIT,
        url: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> CreateAssetResponse:
        """
        Parameters
        ----------
        asset_type : AssetType
            Asset type.

        data : Data
            Asset data.

        name : str
            Asset name.

        description : typing.Optional[str]

        hf_repo : typing.Optional[str]

        hf_token_secret : typing.Optional[str]

        is_public : typing.Optional[bool]
            True if asset is public.

        skip_validation : typing.Optional[bool]
            Skip asset validation.

        transfer_api_type : typing.Optional[TransferApiType]
            Transfer API type.

        url : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        CreateAssetResponse
            Successful Response

        Examples
        --------
        from octoai.asset_library import Data_Checkpoint
        from octoai.client import OctoAI

        client = OctoAI(
            api_key="YOUR_API_KEY",
        )
        client.asset_library.create(
            asset_type="file",
            data=Data_Checkpoint(
                data_type="fp16",
                engine="text/llama-2-7b",
                file_format="safetensors",
            ),
            description="string",
            hf_repo="string",
            hf_token_secret="string",
            is_public=True,
            name="string",
            skip_validation=True,
            transfer_api_type="presigned-url",
            url="string",
        )
        """
        _request: typing.Dict[str, typing.Any] = {"asset_type": asset_type, "data": data, "name": name}
        if description is not OMIT:
            _request["description"] = description
        if hf_repo is not OMIT:
            _request["hf_repo"] = hf_repo
        if hf_token_secret is not OMIT:
            _request["hf_token_secret"] = hf_token_secret
        if is_public is not OMIT:
            _request["is_public"] = is_public
        if skip_validation is not OMIT:
            _request["skip_validation"] = skip_validation
        if transfer_api_type is not OMIT:
            _request["transfer_api_type"] = transfer_api_type
        if url is not OMIT:
            _request["url"] = url
        _response = self._client_wrapper.httpx_client.request(
            method="POST",
            url=urllib.parse.urljoin(f"{self._client_wrapper.get_environment().default}/", "v1/assets"),
            params=jsonable_encoder(
                request_options.get("additional_query_parameters") if request_options is not None else None
            ),
            json=jsonable_encoder(_request)
            if request_options is None or request_options.get("additional_body_parameters") is None
            else {
                **jsonable_encoder(_request),
                **(jsonable_encoder(remove_none_from_dict(request_options.get("additional_body_parameters", {})))),
            },
            headers=jsonable_encoder(
                remove_none_from_dict(
                    {
                        **self._client_wrapper.get_headers(),
                        **(request_options.get("additional_headers", {}) if request_options is not None else {}),
                    }
                )
            ),
            timeout=request_options.get("timeout_in_seconds")
            if request_options is not None and request_options.get("timeout_in_seconds") is not None
            else self._client_wrapper.get_timeout(),
            retries=0,
            max_retries=request_options.get("max_retries") if request_options is not None else 0,  # type: ignore
        )
        if 200 <= _response.status_code < 300:
            return pydantic_v1.parse_obj_as(CreateAssetResponse, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(
                pydantic_v1.parse_obj_as(HttpValidationError, _response.json())  # type: ignore
            )
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def delete(self, asset_id: str, *, request_options: typing.Optional[RequestOptions] = None) -> DeleteAssetResponse:
        """
        Parameters
        ----------
        asset_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        DeleteAssetResponse
            Successful Response

        Examples
        --------
        from octoai.client import OctoAI

        client = OctoAI(
            api_key="YOUR_API_KEY",
        )
        client.asset_library.delete(
            asset_id="asset_id",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            method="DELETE",
            url=urllib.parse.urljoin(
                f"{self._client_wrapper.get_environment().default}/", f"v1/assets/{jsonable_encoder(asset_id)}"
            ),
            params=jsonable_encoder(
                request_options.get("additional_query_parameters") if request_options is not None else None
            ),
            headers=jsonable_encoder(
                remove_none_from_dict(
                    {
                        **self._client_wrapper.get_headers(),
                        **(request_options.get("additional_headers", {}) if request_options is not None else {}),
                    }
                )
            ),
            timeout=request_options.get("timeout_in_seconds")
            if request_options is not None and request_options.get("timeout_in_seconds") is not None
            else self._client_wrapper.get_timeout(),
            retries=0,
            max_retries=request_options.get("max_retries") if request_options is not None else 0,  # type: ignore
        )
        if 200 <= _response.status_code < 300:
            return pydantic_v1.parse_obj_as(DeleteAssetResponse, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(
                pydantic_v1.parse_obj_as(HttpValidationError, _response.json())  # type: ignore
            )
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def complete_upload(
        self,
        asset_id: str,
        *,
        skip_validation: typing.Optional[bool] = OMIT,
        token: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> CompleteAssetUploadResponse:
        """
        Parameters
        ----------
        asset_id : str

        skip_validation : typing.Optional[bool]
            Skip asset validation.

        token : typing.Optional[str]
            Unused

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        CompleteAssetUploadResponse
            Successful Response

        Examples
        --------
        from octoai.client import OctoAI

        client = OctoAI(
            api_key="YOUR_API_KEY",
        )
        client.asset_library.complete_upload(
            asset_id="asset_id",
        )
        """
        _request: typing.Dict[str, typing.Any] = {}
        if skip_validation is not OMIT:
            _request["skip_validation"] = skip_validation
        if token is not OMIT:
            _request["token"] = token
        _response = self._client_wrapper.httpx_client.request(
            method="POST",
            url=urllib.parse.urljoin(
                f"{self._client_wrapper.get_environment().default}/",
                f"v1/assets/{jsonable_encoder(asset_id)}/complete-upload",
            ),
            params=jsonable_encoder(
                request_options.get("additional_query_parameters") if request_options is not None else None
            ),
            json=jsonable_encoder(_request)
            if request_options is None or request_options.get("additional_body_parameters") is None
            else {
                **jsonable_encoder(_request),
                **(jsonable_encoder(remove_none_from_dict(request_options.get("additional_body_parameters", {})))),
            },
            headers=jsonable_encoder(
                remove_none_from_dict(
                    {
                        **self._client_wrapper.get_headers(),
                        **(request_options.get("additional_headers", {}) if request_options is not None else {}),
                    }
                )
            ),
            timeout=request_options.get("timeout_in_seconds")
            if request_options is not None and request_options.get("timeout_in_seconds") is not None
            else self._client_wrapper.get_timeout(),
            retries=0,
            max_retries=request_options.get("max_retries") if request_options is not None else 0,  # type: ignore
        )
        if 200 <= _response.status_code < 300:
            return pydantic_v1.parse_obj_as(CompleteAssetUploadResponse, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(
                pydantic_v1.parse_obj_as(HttpValidationError, _response.json())  # type: ignore
            )
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get(
        self,
        asset_owner_and_name_or_id: str,
        *,
        transfer_api_type: typing.Optional[TransferApiType] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> RetrieveAssetResponse:
        """
        Parameters
        ----------
        asset_owner_and_name_or_id : str

        transfer_api_type : typing.Optional[TransferApiType]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        RetrieveAssetResponse
            Successful Response

        Examples
        --------
        from octoai.client import OctoAI

        client = OctoAI(
            api_key="YOUR_API_KEY",
        )
        client.asset_library.get(
            asset_owner_and_name_or_id="string",
            transfer_api_type="presigned-url",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            method="GET",
            url=urllib.parse.urljoin(
                f"{self._client_wrapper.get_environment().default}/",
                f"v1/assets/{jsonable_encoder(asset_owner_and_name_or_id)}",
            ),
            params=jsonable_encoder(
                remove_none_from_dict(
                    {
                        "transfer_api_type": transfer_api_type,
                        **(
                            request_options.get("additional_query_parameters", {})
                            if request_options is not None
                            else {}
                        ),
                    }
                )
            ),
            headers=jsonable_encoder(
                remove_none_from_dict(
                    {
                        **self._client_wrapper.get_headers(),
                        **(request_options.get("additional_headers", {}) if request_options is not None else {}),
                    }
                )
            ),
            timeout=request_options.get("timeout_in_seconds")
            if request_options is not None and request_options.get("timeout_in_seconds") is not None
            else self._client_wrapper.get_timeout(),
            retries=0,
            max_retries=request_options.get("max_retries") if request_options is not None else 0,  # type: ignore
        )
        if 200 <= _response.status_code < 300:
            return pydantic_v1.parse_obj_as(RetrieveAssetResponse, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(
                pydantic_v1.parse_obj_as(HttpValidationError, _response.json())  # type: ignore
            )
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)


class AsyncAssetLibraryClient:
    def __init__(self, *, client_wrapper: AsyncClientWrapper):
        self._client_wrapper = client_wrapper

    async def list(
        self,
        *,
        name: typing.Optional[str] = None,
        is_public: typing.Optional[bool] = None,
        data_type: typing.Optional[DataType] = None,
        asset_type: typing.Optional[typing.Union[AssetType, typing.Sequence[AssetType]]] = None,
        engine: typing.Optional[typing.Union[BaseEngine, typing.Sequence[BaseEngine]]] = None,
        engine_type: typing.Optional[BaseEngineType] = None,
        limit: typing.Optional[int] = None,
        offset: typing.Optional[int] = None,
        get_preview_urls: typing.Optional[bool] = None,
        asset_ids: typing.Optional[str] = None,
        owner: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> ListAssetsResponse:
        """
        Parameters
        ----------
        name : typing.Optional[str]

        is_public : typing.Optional[bool]

        data_type : typing.Optional[DataType]

        asset_type : typing.Optional[typing.Union[AssetType, typing.Sequence[AssetType]]]

        engine : typing.Optional[typing.Union[BaseEngine, typing.Sequence[BaseEngine]]]

        engine_type : typing.Optional[BaseEngineType]

        limit : typing.Optional[int]

        offset : typing.Optional[int]

        get_preview_urls : typing.Optional[bool]

        asset_ids : typing.Optional[str]

        owner : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        ListAssetsResponse
            Successful Response

        Examples
        --------
        from octoai.client import AsyncOctoAI

        client = AsyncOctoAI(
            api_key="YOUR_API_KEY",
        )
        await client.asset_library.list()
        """
        _response = await self._client_wrapper.httpx_client.request(
            method="GET",
            url=urllib.parse.urljoin(f"{self._client_wrapper.get_environment().default}/", "v1/assets"),
            params=jsonable_encoder(
                remove_none_from_dict(
                    {
                        "name": name,
                        "is_public": is_public,
                        "data_type": data_type,
                        "asset_type": asset_type,
                        "engine": engine,
                        "engine_type": engine_type,
                        "limit": limit,
                        "offset": offset,
                        "get_preview_urls": get_preview_urls,
                        "asset_ids": asset_ids,
                        "owner": owner,
                        **(
                            request_options.get("additional_query_parameters", {})
                            if request_options is not None
                            else {}
                        ),
                    }
                )
            ),
            headers=jsonable_encoder(
                remove_none_from_dict(
                    {
                        **self._client_wrapper.get_headers(),
                        **(request_options.get("additional_headers", {}) if request_options is not None else {}),
                    }
                )
            ),
            timeout=request_options.get("timeout_in_seconds")
            if request_options is not None and request_options.get("timeout_in_seconds") is not None
            else self._client_wrapper.get_timeout(),
            retries=0,
            max_retries=request_options.get("max_retries") if request_options is not None else 0,  # type: ignore
        )
        if 200 <= _response.status_code < 300:
            return pydantic_v1.parse_obj_as(ListAssetsResponse, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(
                pydantic_v1.parse_obj_as(HttpValidationError, _response.json())  # type: ignore
            )
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def create(
        self,
        *,
        asset_type: AssetType,
        data: Data,
        name: str,
        description: typing.Optional[str] = OMIT,
        hf_repo: typing.Optional[str] = OMIT,
        hf_token_secret: typing.Optional[str] = OMIT,
        is_public: typing.Optional[bool] = OMIT,
        skip_validation: typing.Optional[bool] = OMIT,
        transfer_api_type: typing.Optional[TransferApiType] = OMIT,
        url: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> CreateAssetResponse:
        """
        Parameters
        ----------
        asset_type : AssetType
            Asset type.

        data : Data
            Asset data.

        name : str
            Asset name.

        description : typing.Optional[str]

        hf_repo : typing.Optional[str]

        hf_token_secret : typing.Optional[str]

        is_public : typing.Optional[bool]
            True if asset is public.

        skip_validation : typing.Optional[bool]
            Skip asset validation.

        transfer_api_type : typing.Optional[TransferApiType]
            Transfer API type.

        url : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        CreateAssetResponse
            Successful Response

        Examples
        --------
        from octoai.asset_library import Data_Checkpoint
        from octoai.client import AsyncOctoAI

        client = AsyncOctoAI(
            api_key="YOUR_API_KEY",
        )
        await client.asset_library.create(
            asset_type="file",
            data=Data_Checkpoint(
                data_type="fp16",
                engine="text/llama-2-7b",
                file_format="safetensors",
            ),
            description="string",
            hf_repo="string",
            hf_token_secret="string",
            is_public=True,
            name="string",
            skip_validation=True,
            transfer_api_type="presigned-url",
            url="string",
        )
        """
        _request: typing.Dict[str, typing.Any] = {"asset_type": asset_type, "data": data, "name": name}
        if description is not OMIT:
            _request["description"] = description
        if hf_repo is not OMIT:
            _request["hf_repo"] = hf_repo
        if hf_token_secret is not OMIT:
            _request["hf_token_secret"] = hf_token_secret
        if is_public is not OMIT:
            _request["is_public"] = is_public
        if skip_validation is not OMIT:
            _request["skip_validation"] = skip_validation
        if transfer_api_type is not OMIT:
            _request["transfer_api_type"] = transfer_api_type
        if url is not OMIT:
            _request["url"] = url
        _response = await self._client_wrapper.httpx_client.request(
            method="POST",
            url=urllib.parse.urljoin(f"{self._client_wrapper.get_environment().default}/", "v1/assets"),
            params=jsonable_encoder(
                request_options.get("additional_query_parameters") if request_options is not None else None
            ),
            json=jsonable_encoder(_request)
            if request_options is None or request_options.get("additional_body_parameters") is None
            else {
                **jsonable_encoder(_request),
                **(jsonable_encoder(remove_none_from_dict(request_options.get("additional_body_parameters", {})))),
            },
            headers=jsonable_encoder(
                remove_none_from_dict(
                    {
                        **self._client_wrapper.get_headers(),
                        **(request_options.get("additional_headers", {}) if request_options is not None else {}),
                    }
                )
            ),
            timeout=request_options.get("timeout_in_seconds")
            if request_options is not None and request_options.get("timeout_in_seconds") is not None
            else self._client_wrapper.get_timeout(),
            retries=0,
            max_retries=request_options.get("max_retries") if request_options is not None else 0,  # type: ignore
        )
        if 200 <= _response.status_code < 300:
            return pydantic_v1.parse_obj_as(CreateAssetResponse, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(
                pydantic_v1.parse_obj_as(HttpValidationError, _response.json())  # type: ignore
            )
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def delete(
        self, asset_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> DeleteAssetResponse:
        """
        Parameters
        ----------
        asset_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        DeleteAssetResponse
            Successful Response

        Examples
        --------
        from octoai.client import AsyncOctoAI

        client = AsyncOctoAI(
            api_key="YOUR_API_KEY",
        )
        await client.asset_library.delete(
            asset_id="asset_id",
        )
        """
        _response = await self._client_wrapper.httpx_client.request(
            method="DELETE",
            url=urllib.parse.urljoin(
                f"{self._client_wrapper.get_environment().default}/", f"v1/assets/{jsonable_encoder(asset_id)}"
            ),
            params=jsonable_encoder(
                request_options.get("additional_query_parameters") if request_options is not None else None
            ),
            headers=jsonable_encoder(
                remove_none_from_dict(
                    {
                        **self._client_wrapper.get_headers(),
                        **(request_options.get("additional_headers", {}) if request_options is not None else {}),
                    }
                )
            ),
            timeout=request_options.get("timeout_in_seconds")
            if request_options is not None and request_options.get("timeout_in_seconds") is not None
            else self._client_wrapper.get_timeout(),
            retries=0,
            max_retries=request_options.get("max_retries") if request_options is not None else 0,  # type: ignore
        )
        if 200 <= _response.status_code < 300:
            return pydantic_v1.parse_obj_as(DeleteAssetResponse, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(
                pydantic_v1.parse_obj_as(HttpValidationError, _response.json())  # type: ignore
            )
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def complete_upload(
        self,
        asset_id: str,
        *,
        skip_validation: typing.Optional[bool] = OMIT,
        token: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> CompleteAssetUploadResponse:
        """
        Parameters
        ----------
        asset_id : str

        skip_validation : typing.Optional[bool]
            Skip asset validation.

        token : typing.Optional[str]
            Unused

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        CompleteAssetUploadResponse
            Successful Response

        Examples
        --------
        from octoai.client import AsyncOctoAI

        client = AsyncOctoAI(
            api_key="YOUR_API_KEY",
        )
        await client.asset_library.complete_upload(
            asset_id="asset_id",
        )
        """
        _request: typing.Dict[str, typing.Any] = {}
        if skip_validation is not OMIT:
            _request["skip_validation"] = skip_validation
        if token is not OMIT:
            _request["token"] = token
        _response = await self._client_wrapper.httpx_client.request(
            method="POST",
            url=urllib.parse.urljoin(
                f"{self._client_wrapper.get_environment().default}/",
                f"v1/assets/{jsonable_encoder(asset_id)}/complete-upload",
            ),
            params=jsonable_encoder(
                request_options.get("additional_query_parameters") if request_options is not None else None
            ),
            json=jsonable_encoder(_request)
            if request_options is None or request_options.get("additional_body_parameters") is None
            else {
                **jsonable_encoder(_request),
                **(jsonable_encoder(remove_none_from_dict(request_options.get("additional_body_parameters", {})))),
            },
            headers=jsonable_encoder(
                remove_none_from_dict(
                    {
                        **self._client_wrapper.get_headers(),
                        **(request_options.get("additional_headers", {}) if request_options is not None else {}),
                    }
                )
            ),
            timeout=request_options.get("timeout_in_seconds")
            if request_options is not None and request_options.get("timeout_in_seconds") is not None
            else self._client_wrapper.get_timeout(),
            retries=0,
            max_retries=request_options.get("max_retries") if request_options is not None else 0,  # type: ignore
        )
        if 200 <= _response.status_code < 300:
            return pydantic_v1.parse_obj_as(CompleteAssetUploadResponse, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(
                pydantic_v1.parse_obj_as(HttpValidationError, _response.json())  # type: ignore
            )
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get(
        self,
        asset_owner_and_name_or_id: str,
        *,
        transfer_api_type: typing.Optional[TransferApiType] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> RetrieveAssetResponse:
        """
        Parameters
        ----------
        asset_owner_and_name_or_id : str

        transfer_api_type : typing.Optional[TransferApiType]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        RetrieveAssetResponse
            Successful Response

        Examples
        --------
        from octoai.client import AsyncOctoAI

        client = AsyncOctoAI(
            api_key="YOUR_API_KEY",
        )
        await client.asset_library.get(
            asset_owner_and_name_or_id="string",
            transfer_api_type="presigned-url",
        )
        """
        _response = await self._client_wrapper.httpx_client.request(
            method="GET",
            url=urllib.parse.urljoin(
                f"{self._client_wrapper.get_environment().default}/",
                f"v1/assets/{jsonable_encoder(asset_owner_and_name_or_id)}",
            ),
            params=jsonable_encoder(
                remove_none_from_dict(
                    {
                        "transfer_api_type": transfer_api_type,
                        **(
                            request_options.get("additional_query_parameters", {})
                            if request_options is not None
                            else {}
                        ),
                    }
                )
            ),
            headers=jsonable_encoder(
                remove_none_from_dict(
                    {
                        **self._client_wrapper.get_headers(),
                        **(request_options.get("additional_headers", {}) if request_options is not None else {}),
                    }
                )
            ),
            timeout=request_options.get("timeout_in_seconds")
            if request_options is not None and request_options.get("timeout_in_seconds") is not None
            else self._client_wrapper.get_timeout(),
            retries=0,
            max_retries=request_options.get("max_retries") if request_options is not None else 0,  # type: ignore
        )
        if 200 <= _response.status_code < 300:
            return pydantic_v1.parse_obj_as(RetrieveAssetResponse, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(
                pydantic_v1.parse_obj_as(HttpValidationError, _response.json())  # type: ignore
            )
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)
