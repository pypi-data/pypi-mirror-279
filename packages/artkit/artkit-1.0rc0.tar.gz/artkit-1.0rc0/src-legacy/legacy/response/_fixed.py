"""
Implementation of ``LLMResponder``.
"""

from __future__ import annotations

import logging
from collections.abc import Iterable, Iterator
from typing import Any, Generic, TypeVar, cast

from fluxus.lineage import LabelingProducer

from pytools.api import as_tuple

from ..challenge import EmptyChallenge
from ._response import Response, SingleTurnResponse

log = logging.getLogger(__name__)

__all__ = [
    "FixedResponder",
    "FixedResponse",
]

#
# Type variables
#
# Naming convention used here:
# _ret for covariant type variables used in return positions
# _arg for contravariant type variables used in argument positions

T_Response_ret = TypeVar("T_Response_ret", bound=Response[Any], covariant=True)


#
# Classes
#


class FixedResponder(LabelingProducer[T_Response_ret], Generic[T_Response_ret]):
    """
    A responder that always produces the same responses.
    """

    #: The responses produced by this responder.
    responses: tuple[T_Response_ret, ...]

    def __init__(self, responses: Iterable[T_Response_ret]) -> None:
        """
        :param responses: the responses to produce
        """
        super().__init__()
        self.responses = as_tuple(
            responses,
            element_type=cast(type[T_Response_ret], Response),
            arg_name="responses",
        )

    def produce(self) -> Iterator[T_Response_ret]:
        """
        Iterate over responses.

        :return: an iterator containing the responses
        """
        return iter(self.responses)


class FixedResponse(SingleTurnResponse[EmptyChallenge]):
    """
    A response that was not generated by an LLM system based on a challenge, but
    that has been pre-defined.

    The challenge is always an :class:`EmptyChallenge`.

    This is useful for testing and debugging purposes.
    """

    def __init__(self, message: str) -> None:
        """
        :param message: the message of the response
        """
        super().__init__(message=message, challenge=EmptyChallenge())
